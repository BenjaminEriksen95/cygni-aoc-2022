/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package aoc;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Scanner;
import org.jgrapht.Graph;
import org.jgrapht.alg.interfaces.ShortestPathAlgorithm;
import org.jgrapht.alg.shortestpath.DijkstraShortestPath;
import org.jgrapht.graph.DefaultEdge;
import org.jgrapht.graph.builder.GraphTypeBuilder;


class Node {

    Character value;
    int x;
    int y;
    public Node(Character value, int x, int y) {
        this.value = value;
        this.x = x;
        this.y = y;
    }

    public String toString() {
        return value+"("+ x + ","+y +")";
    }

    public boolean canMove(Node neighbour) {

        if (this.value == 'E') {
            return 1 >= neighbour.value - 'z';
        }
        if (neighbour.value == 'E') {
            return 1 >= Math.abs('z' - this.value);
        }
        if (neighbour.value == 'S')  {
            return false;
        }
        if (this.value == 'S')  {
            return 1 >= neighbour.value - 'a';
        }
        return 1 >= neighbour.value - this.value;
    }
}

public class App {

    private static Node start;
    private static Node goal;
    public static Integer getSolutionPart1(Graph<Node, DefaultEdge> graph) {
        ShortestPathAlgorithm<Node, DefaultEdge> alg = new DijkstraShortestPath<>(graph);
        return alg.getPath(start, goal).getLength();
    }

    public static Integer getSolutionPart2(Graph<Node, DefaultEdge> graph) {
        ShortestPathAlgorithm<Node, DefaultEdge> alg = new DijkstraShortestPath<>(graph);
        var score = graph.vertexSet().parallelStream().min(Comparator.comparingInt(i -> minFunc(i, alg)));
        return alg.getPath(score.get(), goal).getLength();
    }

    private static int minFunc(Node n, ShortestPathAlgorithm<Node, DefaultEdge> alg) {
        if (n.value == 'a') {
            var k = alg.getPath(n, goal);
            return (k != null) ? k.getLength() : Integer.MAX_VALUE;
        }
        return Integer.MAX_VALUE;
    }

    public static void main(String[] args) throws IOException {
        System.out.println("java");
        var graph = parseInput("input.txt");
        String part = System.getenv("part") == null ? "part1" : System.getenv("part");
        if (part.equals("part2"))
            System.out.println(getSolutionPart2(graph));
        else
            System.out.println(getSolutionPart1(graph));
    }

    private static Graph<Node, DefaultEdge> parseInput(String filename) throws IOException {
        File file = new File(filename);
        ArrayList<ArrayList<Node>> map = new ArrayList<>();
        Scanner scanner = new Scanner(file);

        var graph = GraphTypeBuilder
            .<Node, DefaultEdge>directed()
            .weighted(false)
            .allowingSelfLoops(false)
            .edgeClass(DefaultEdge.class).buildGraph();

        for (int l = 0; scanner.hasNextLine(); l++) {
            var line = scanner.nextLine();
            map.add(new ArrayList<>());
            for (int i = 0; i < line.length(); i++) {
                var n = new Node(line.charAt(i), i, l);
                map.get(l).add(n);
                graph.addVertex(n);
            }
        }
        for (int y = 0; y < map.get(0).size(); y++) {
            for (int x = 0; x < map.size(); x++) {
                var current = map.get(x).get(y);
                if (map.get(x).get(y).value == 'S') start = map.get(x).get(y);
                if (map.get(x).get(y).value == 'E') goal = map.get(x).get(y);
                if (x - 1 >= 0 && current.canMove(map.get(x - 1).get(y)))
                    graph.addEdge(current, map.get(x - 1).get(y));
                if (x + 1 < map.size() && current.canMove(map.get(x + 1).get(y)))
                    graph.addEdge(current, map.get(x + 1).get(y));
                if (y - 1 >= 0 && current.canMove(map.get(x).get(y - 1)))
                    graph.addEdge(current, map.get(x).get(y - 1));
                if (y + 1 < map.get(0).size() && current.canMove(map.get(x).get(y + 1)))
                    graph.addEdge(current, map.get(x).get(y + 1));
            }
        }
        scanner.close(); return graph;
    }

}
